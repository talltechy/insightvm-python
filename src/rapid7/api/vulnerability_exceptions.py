"""
Vulnerability Exceptions API Module

This module provides functionality to manage vulnerability exceptions in
InsightVM, including creating exceptions, managing their lifecycle, and
setting expiration dates.

Vulnerability exceptions allow security teams to document and track
decisions about vulnerabilities that:
- Are false positives
- Have acceptable risk
- Have compensating controls
- Require temporary exclusion from reporting

Classes:
    VulnerabilityExceptionsAPI: Main API class for vulnerability exception
                                 operations
"""

from typing import Dict, List, Optional, Any
from .base import BaseAPI


class VulnerabilityExceptionsAPI(BaseAPI):
    """
    API client for managing vulnerability exceptions in InsightVM.

    Provides methods to:
    - List and retrieve vulnerability exceptions
    - Create new exceptions with scope and reason
    - Delete exceptions
    - Manage exception status (approve, reject, recall)
    - Handle exception expiration dates

    Inherits from BaseAPI for authentication and request handling.
    """

    def list(
        self,
        page: int = 0,
        size: int = 10,
        sort: Optional[List[str]] = None
    ) -> Dict:
        """
        Retrieve a page of vulnerability exceptions.

        Args:
            page: Zero-based page index (default: 0)
            size: Number of records per page, max 500 (default: 10)
            sort: List of sorting criteria in format
                  ["property,ASC|DESC"]
                  Example: ["submit.date,DESC", "scope.vulnerability,ASC"]

        Returns:
            Dict containing:
                - resources: List of vulnerability exception objects
                - page: Page metadata (number, size, totalResources, etc.)
                - links: HATEOAS links for navigation

        Example:
            >>> # Get first page with default size
            >>> exceptions = client.vulnerability_exceptions.list()
            >>> for exc in exceptions['resources']:
            ...     print(f"{exc['id']}: {exc['state']}")

            >>> # Get larger page with custom sorting
            >>> exceptions = client.vulnerability_exceptions.list(
            ...     page=0,
            ...     size=50,
            ...     sort=["submit.date,DESC"]
            ... )
        """
        size = self._validate_page_size(size)

        params: Dict[str, Any] = {
            'page': page,
            'size': size
        }

        if sort:
            params['sort'] = sort

        endpoint = '/api/3/vulnerability_exceptions'
        return self._request('GET', endpoint, params=params)

    def get_exception(self, exception_id: int) -> Dict:
        """
        Retrieve detailed information about a specific vulnerability
        exception.

        Args:
            exception_id: Unique identifier of the vulnerability exception

        Returns:
            Dict containing complete exception details including:
                - id: Exception identifier
                - state: Current status (under_review, approved, rejected,
                         deleted, recall_requested)
                - scope: Scope of the exception (vulnerability, asset,
                         asset group, etc.)
                - submit: Submission details (user, date, reason, comment)
                - review: Review details if processed (user, date, comment)
                - expires: Expiration date if set (ISO 8601 format)
                - links: HATEOAS links

        Example:
            >>> exception = client.vulnerability_exceptions.get_exception(42)
            >>> print(f"Status: {exception['state']}")
            >>> print(f"Reason: {exception['submit']['reason']}")
            >>> if 'expires' in exception:
            ...     print(f"Expires: {exception['expires']}")
        """
        endpoint = f'/api/3/vulnerability_exceptions/{exception_id}'
        return self._request('GET', endpoint)

    def create(self, vulnerability_exception: Dict) -> Dict:
        """
        Create a new vulnerability exception.

        The exception scope determines what assets/vulnerabilities are
        affected. Scope types:
        - Global: All instances of a vulnerability across all assets
        - Site: Vulnerability instances in specific sites
        - Asset Group: Vulnerability instances in asset groups
        - Asset: Specific vulnerability instances on specific assets

        Args:
            vulnerability_exception: Dict containing:
                - scope: (required) Exception scope definition
                    - type: "global", "site", "asset_group", or "asset"
                    - vulnerability: Vulnerability ID
                    - id: (if scoped) Site/Asset Group/Asset ID
                    - port: (optional) Specific port number
                    - key: (optional) Specific service key
                - submit: (required) Submission details
                    - reason: Exception reason (false_positive,
                              compensating_control, acceptable_risk,
                              other)
                    - comment: (optional) Additional explanation
                - expires: (optional) Expiration date (ISO 8601 format)

        Returns:
            Dict containing:
                - id: ID of created exception
                - links: Links to the new exception resource

        Example:
            >>> # Create global exception for false positive
            >>> new_exception = {
            ...     "scope": {
            ...         "type": "global",
            ...         "vulnerability": "apache-httpd-cve-2002-0392"
            ...     },
            ...     "submit": {
            ...         "reason": "false_positive",
            ...         "comment": "This CVE does not apply to our config"
            ...     },
            ...     "expires": "2025-12-31T23:59:59.000Z"
            ... }
            >>> result = client.vulnerability_exceptions.create(
            ...     new_exception
            ... )
            >>> print(f"Created exception: {result['id']}")

            >>> # Create asset-specific exception
            >>> asset_exception = {
            ...     "scope": {
            ...         "type": "asset",
            ...         "vulnerability": "ssh-weak-cipher",
            ...         "id": 123,
            ...         "port": 22
            ...     },
            ...     "submit": {
            ...         "reason": "compensating_control",
            ...         "comment": "Protected by network segmentation"
            ...     }
            ... }
            >>> result = client.vulnerability_exceptions.create(
            ...     asset_exception
            ... )
        """
        endpoint = '/api/3/vulnerability_exceptions'
        return self._request('POST', endpoint, json=vulnerability_exception)

    def delete_exception(self, exception_id: int) -> None:
        """
        Delete a vulnerability exception.

        This permanently removes the exception and restores normal
        vulnerability reporting for the affected scope.

        Args:
            exception_id: Unique identifier of the exception to delete

        Returns:
            None

        Example:
            >>> # Delete an exception
            >>> client.vulnerability_exceptions.delete_exception(42)
            >>> print("Exception deleted successfully")
        """
        endpoint = f'/api/3/vulnerability_exceptions/{exception_id}'
        self._request('DELETE', endpoint)

    def update_status(
        self,
        exception_id: int,
        status: str,
        comment: Optional[str] = None
    ) -> Dict:
        """
        Update the status of a vulnerability exception.

        Valid status transitions:
        - "approve": Move exception to approved state
        - "reject": Move exception to rejected state
        - "recall": Request to recall an exception (request review)

        Args:
            exception_id: Unique identifier of the exception
            status: New status ("approve", "reject", or "recall")
            comment: Optional comment explaining the status change

        Returns:
            Dict containing HATEOAS links to the updated exception

        Raises:
            ValueError: If status is not one of the valid values

        Example:
            >>> # Approve an exception with comment
            >>> result = client.vulnerability_exceptions.update_status(
            ...     exception_id=42,
            ...     status="approve",
            ...     comment="Verified compensating controls in place"
            ... )

            >>> # Reject an exception
            >>> result = client.vulnerability_exceptions.update_status(
            ...     exception_id=43,
            ...     status="reject",
            ...     comment="Insufficient justification"
            ... )
        """
        # Validate status parameter
        allowed_statuses = {"approve", "reject", "recall"}
        if status not in allowed_statuses:
            raise ValueError(
                f"Invalid status '{status}'. Must be one of: "
                f"{', '.join(sorted(allowed_statuses))}"
            )

        endpoint = (f'/api/3/vulnerability_exceptions/{exception_id}/'
                    f'{status}')

        body = {}
        if comment:
            body['comment'] = comment

        return self._request('POST', endpoint, json=body)

    def approve(self, exception_id: int,
                comment: Optional[str] = None) -> Dict:
        """
        Approve a vulnerability exception.

        Convenience method that performs the 'approve' action, which
        moves the exception to 'approved' state. Approved exceptions
        suppress vulnerability findings in reports and dashboards.

        Args:
            exception_id: Unique identifier of the exception to approve
            comment: Optional comment explaining the approval

        Returns:
            Dict containing HATEOAS links to the updated exception

        Example:
            >>> # Approve exception with comment
            >>> result = client.vulnerability_exceptions.approve(
            ...     exception_id=42,
            ...     comment="Risk accepted by security team"
            ... )
            >>> print("Exception approved")
        """
        return self.update_status(exception_id, 'approve', comment)

    def reject(self, exception_id: int,
               comment: Optional[str] = None) -> Dict:
        """
        Reject a vulnerability exception.

        Convenience method that performs the 'reject' action, which
        moves the exception to 'rejected' state. Rejected exceptions
        do not suppress findings; the vulnerability remains active in
        reporting.

        Args:
            exception_id: Unique identifier of the exception to reject
            comment: Optional comment explaining the rejection

        Returns:
            Dict containing HATEOAS links to the updated exception

        Example:
            >>> # Reject exception with explanation
            >>> result = client.vulnerability_exceptions.reject(
            ...     exception_id=43,
            ...     comment="Requires additional justification"
            ... )
            >>> print("Exception rejected")
        """
        return self.update_status(exception_id, 'reject', comment)

    def recall(self, exception_id: int,
               comment: Optional[str] = None) -> Dict:
        """
        Recall a vulnerability exception for re-review.

        Convenience method that performs the 'recall' action, which
        moves the exception to 'recall_requested' state for re-review.

        Args:
            exception_id: Unique identifier of the exception to recall
            comment: Optional comment explaining why recall is needed

        Returns:
            Dict containing HATEOAS links to the updated exception

        Example:
            >>> # Recall exception due to changed circumstances
            >>> result = client.vulnerability_exceptions.recall(
            ...     exception_id=42,
            ...     comment="Compensating control no longer in place"
            ... )
            >>> print("Exception recalled for review")
        """
        return self.update_status(exception_id, 'recall', comment)

    def get_expiration(self, exception_id: int) -> str:
        """
        Retrieve the expiration date of a vulnerability exception.

        Args:
            exception_id: Unique identifier of the exception

        Returns:
            str: Expiration date in ISO 8601 format
                 (e.g., "2025-12-31T23:59:59.000Z")
                 Returns empty string if no expiration is set

        Example:
            >>> expiration = client.vulnerability_exceptions.get_expiration(
            ...     42
            ... )
            >>> if expiration:
            ...     print(f"Exception expires: {expiration}")
            ... else:
            ...     print("Exception has no expiration date")
        """
        endpoint = f'/api/3/vulnerability_exceptions/{exception_id}/expires'
        response = self._request('GET', endpoint)
        # API returns plain text date string
        return response if isinstance(response, str) else ""

    def set_expiration(
        self,
        exception_id: int,
        expiration_date: str
    ) -> Dict:
        """
        Set or update the expiration date for a vulnerability exception.

        Expired exceptions automatically revert to normal vulnerability
        reporting. This allows time-limited acceptance of risks.

        Args:
            exception_id: Unique identifier of the exception
            expiration_date: Expiration date in ISO 8601 format
                           Example: "2025-12-31T23:59:59.000Z"

        Returns:
            Dict containing HATEOAS links to the updated exception

        Example:
            >>> # Set expiration to end of year
            >>> result = client.vulnerability_exceptions.set_expiration(
            ...     exception_id=42,
            ...     expiration_date="2025-12-31T23:59:59.000Z"
            ... )
            >>> print("Expiration date updated")

            >>> # Extend expiration by one year
            >>> from datetime import datetime, timedelta
            >>> new_date = (datetime.now() +
            ...             timedelta(days=365)).isoformat() + 'Z'
            >>> result = client.vulnerability_exceptions.set_expiration(
            ...     exception_id=42,
            ...     expiration_date=new_date
            ... )
        """
        endpoint = f'/api/3/vulnerability_exceptions/{exception_id}/expires'
        # API expects plain text date string as body
        return self._request(
            'PUT',
            endpoint,
            data=expiration_date,
            headers={'Content-Type': 'text/plain'}
        )

    def get_all(self, sort: Optional[List[str]] = None) -> List[Dict]:
        """
        Retrieve all vulnerability exceptions by iterating through all
        pages.

        This is a convenience method that handles pagination automatically.
        Use with caution for large datasets.

        Args:
            sort: Optional list of sorting criteria in format
                  ["property,ASC|DESC"]
                  Example: ["submit.date,DESC"]

        Returns:
            List[Dict]: Complete list of all vulnerability exception
                        objects

        Example:
            >>> # Get all exceptions sorted by submission date
            >>> all_exceptions = client.vulnerability_exceptions.get_all(
            ...     sort=["submit.date,DESC"]
            ... )
            >>> print(f"Total exceptions: {len(all_exceptions)}")
            >>> for exc in all_exceptions:
            ...     print(f"{exc['id']}: {exc['state']} - "
            ...           f"{exc['scope']['vulnerability']}")
        """
        all_exceptions = []
        page = 0
        page_size = 500

        while True:
            response = self.list(page=page, size=page_size, sort=sort)
            exceptions = response.get('resources', [])

            if not exceptions:
                break

            all_exceptions.extend(exceptions)

            page_info = response.get('page', {})
            total_pages = page_info.get('totalPages', 1)

            if page >= total_pages - 1:
                break

            page += 1

        return all_exceptions

    def _validate_page_size(self, size: int) -> int:
        """
        Validate and cap page size to API maximum.

        Args:
            size: Requested page size

        Returns:
            int: Validated page size (min 1, max 500)
        """
        max_size = 500
        return max(1, min(size, max_size))
